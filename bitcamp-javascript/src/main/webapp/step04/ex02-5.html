<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>객체 프로퍼티 - arrow 함수와 this </title>

<script>
"use strict"

/* var obj1 = new Object();
obj1.result =0;
//{}안에 문장이 2개 이상일경우 각 문장 마무리에 ; 필요

// 같은 객체에 소속된 프로퍼트(변수, 함수)를 가르킬때는
// 반드시 this
obj1.plus = (value) => {this.result += value};
obj1.minus = (value) => {this.result -= value};
obj1.plus2 = function(value) => {this.result += value};
obj1.minus2 =function(value) => {this.result -= value};

var obj2={
   result:0,
   plus: value =>{this.result += value},
   minus: value =>{this.result -= value}
   plus(value) =>{this.result += value},
   minus(value) =>{this.result -= value}
}

obj1.plus(100);
obj1.plus(50);
obj1.plus(70);

obj2.minus(10);
obj2.minus(5);
obj2.minus(7); */

//Arrow 함수에서 this는 무조건 window 객체를 가르킨다.
// 그래서 객체 함수로 사용할 때 주의해야한다.
// => 사실상 Arroy 함수는 객체의 메서드를 만들 때 사용하려고 만든 문법이 아니라, 함수를 호출할 때 파라미터 값으로 전달하거나
// 함수의 리턴 값으로 받기 쉽도록 하기 위해 만든 문법이다.
function test(){
    console.log(this);
}
//객체 없이 함수를 호출할 때는 this 라는 변수가 존재하지 않는다.
test();

var obj3=new Object();
obj3.value = 100;
obj3.f1 = test; // 이렇게 일반 함수를 객체에 프로퍼티로 저장 할 수 있다.
obj3.f2=function(){ // 당연히 익명 함수도 저장 가능
    console.log(this)
    };
//this : 이 함수가 소속된 객체를 가르킨다.
obj3.f3=()=>{ // Array 함수의 this 는 무조건 window 객체이다.
    console.log(this)
    };
obj3.f1();
obj3.f2(); 
obj3.f3(); 
//console.log(obj1.result, obj2.result)
</script>

</body>
</html>